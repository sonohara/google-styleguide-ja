*原著バージョン: https://github.com/google/styleguide/blob/9ae38d43e38a5b182092723d0f1295c3b80b1e06/go/guide.md*

# Go Style Guide

https://google.github.io/styleguide/go/guide

[Overview](index.ja.md) | [Style Guide](guide.ja.md) | [Style Decisions](decisions.ja.md) | [Best practices](best-practices.ja.md)

{% raw %}

**Note:** これは、Googleにおける [Go Style](index.ja.md) の概要を説明する一連のドキュメントの一部です。
この文書は **[normative](index.ja.md#normative) と [canonical](index.ja.md#canonical)** です。
詳しくは [the overview](index.ja.md#about) を参照してください。

<a id="principles"></a>

## Style principles

読みやすいGoコードを書くための考え方をまとめた、いくつかの包括的な原則があります。
読みやすいコードの属性として、重要度の高い順に次のようなものがあります：

1. **[Clarity]: 明瞭**: 目的、根拠が明確である。
1. **[Simplicity]: 簡潔**: できるだけシンプルな方法で目的を達成する。
1. **[Concision]: 無駄がない**: S/N比が高い。
1. **[Maintainability]: 保守性**: メンテナンスがしやすい。
1. **[Consistency]: 一貫性**: より広範なGoogleのコードベースと整合性がある。

[Clarity]: #clarity
[Simplicity]: #simplicity
[Concision]: #concision
[Maintainability]: #maintainability
[Consistency]: #consistency

<a id="clarity"></a>

### Clarity

可読性の中核となる目標は、読み手にとって明確なコードを作成することです。
わかりやすさは、主に効果的なネーミング、役に立つ解説、効率的なコード構成によって達成されます。

明瞭さは、コードの作者ではなく、読者のレンズを通して見るべきものです。
コードは書きやすさよりも、読みやすさが重要です。
コードの明確さには、2つの明確な側面があります：

* [コードは実際に何をしているのか？](#clarity-purpose)
* [なぜ、そのコードがそうなっているのか？](#clarity-rationale)

<a id="clarity-purpose"></a>

#### コードは実際に何をしているのか？

Goは、コードが何をしているのかを比較的簡単に確認できるように設計されています。
不明な点がある場合、あるいはコードを理解するために予備知識が必要な場合、将来の読者のためにコードの目的を明確にするために時間を費やす価値があります。
例えば、以下のようなことが考えられます：

* より説明的な変数名を使用する
* コメントを追加する
* 空白とコメントでコードを分割する
* よりモジュール化するために、コードを別の関数/メソッドにリファクタリングする。

ここでは、一概には言えませんが、Goのコードを開発する際には、わかりやすさを優先することが重要です。

<a id="clarity-rationale"></a>

#### なぜ、そのコードがそうなっているのか？

コードの根拠は、変数名、関数名、メソッド名、パッケージ名などで十分に伝えられることが多いです。
そうでないところは、解説を加えることが重要です。
「なぜ」は特に読み手がよく知らないニュアンスがコードに含まれている場合に重要です。

* 言葉のニュアンス, e.g., クロージャはループ変数を捕捉するが、クロージャは何行も先にある。
* ビジネスロジックのニュアンス, e.g., 実際のユーザーとユーザーになりすました人を区別する必要があるアクセス制御チェック。

APIを正しく使うためには、注意が必要な場合があります。
例えば、あるコードがパフォーマンス上の理由から複雑に入り組んでいてフォローが難しい場合や、複雑な一連の数学的演算が予期せぬ方法で型変換を使用する場合があります。
このような場合、将来の保守者が間違わないように、また読者がリバースエンジニアリングしなくてもコードを理解できるように、付属の解説書や文書でこれらの点を説明することが重要です。

また、解説を追加するなどして分かりやすくしようとすると、かえってコードが乱雑になったり、コードが既に述べていることを再掲したり、コードと矛盾したり、コメントを最新に保つためのメンテナンスの負担が増えたりして、コードの目的が不明瞭になることがあることも知っておく必要があります。
冗長なコメントを追加するのではなく、コードが自ら語るようにしましょう（例えば、シンボル名自体を自己記述するようにする）。
コメントは、コードが何をやっているかではなく、なぜそうなるのかを説明する方が良い場合が多いのです。

Googleのコードベースは、ほぼ統一されており、一貫性があります。
見慣れないパターンを使うなどして目立つコードには、それなりの理由があることがよくあります（一般的にはパフォーマンスのため）。
この指針を維持することは、新しいコードを読むときに、読者がどこに注意を向けるべきかを明確にするために重要です。

標準ライブラリには、この原則を実践している例が数多く掲載されています。
その中でも特に:

* [`package sort`](https://cs.opensource.google/go/go/+/refs/tags/go1.19.2:src/sort/sort.go) のメンテナコメント
* [同じパッケージ内で実行可能な良いサンプル](https://cs.opensource.google/go/go/+/refs/tags/go1.19.2:src/sort/example_search_test.go)をで提供することで、[godocに表示](https://pkg.go.dev/sort#pkg-examples)されるユーザーとメンテナの両方に利益をもたらします。
* [`strings.Cut`](https://pkg.go.dev/strings#Cut) はわずか4行のコードですが、[コールサイトの明快さと正しさ](https://github.com/golang/go/issues/46336)を向上させます。

<a id="simplicity"></a>

### Simplicity

Go のコードは、それを使う人、読む人、保守する人にとってシンプルであるべきです。
Go のコードは、動作と性能の両面から、目的を達成するために最もシンプルな方法で書かれるべきです。Google Goのコードベース内では、シンプルなコードです：

* 上から下まで読みやすい
* 何をしているのかすでに知っていることを前提にしない
* 先行するコードのすべてを記憶できることを前提としない
* 不要な抽象度がない
* 平凡なものに注意を喚起するような名称を持たない。
* 価値観や判断の伝播を読者に明確にする
* 将来的な逸脱を避けるために、コードが何をやっているかではなく、なぜやっているかを説明するコメントがある
* 単体で成立するドキュメントがある
* 有益なエラーや有益なテストの失敗がある
* 「賢い」コードと相互に排他的であることが多いかもしれない

コードの簡略化とAPI利用の簡略化の間でトレードオフが生じることがあります。
例えば、APIのエンドユーザーがより簡単にAPIを正しく呼び出せるように、コードをより複雑にすることに意義があるかもしれません。
逆に、APIのエンドユーザーに少し余分な作業を任せて、コードがシンプルでわかりやすい状態を維持することも意義があるかもしれません。

コードが複雑さを必要とする場合、複雑さは意図的に追加する必要があります。
これは通常、追加のパフォーマンスが必要な場合や、特定のライブラリやサービスの複数の異なった利用者がいる場合に必要です。
複雑さは正当化されるかもしれませんが、利用者や将来の保守者が複雑さを理解し、ナビゲートできるように、付随する文書が付属している必要があります。
特に、そのコードを使うのに「単純」な方法と「複雑」な方法の両方がある場合は、正しい使い方を示すテストや例で補足する必要があります。

この原則は、複雑なコードはGoで書けない、または書くべきではない、あるいはGoのコードは複雑であってはいけないということを意味するものではありません。
私たちは、不必要な複雑さを避けるコードベースを目指しており、複雑さが現れた場合は、問題のコードを理解し維持するために注意が必要であることを示すものです。
理想的には、その根拠を説明し、取るべき注意を明らかにする解説が付随していることが望ましいです。
バッファを事前に確保し、それをゴルーチンのライフタイムを通して再利用するような、より複雑なアプローチを必要とすることがよくあります。
メンテナンス担当者がこれを見たとき、問題のコードがパフォーマンスクリティカルであることを示す手がかりとなり、今後の変更に際しての注意に影響を与えるはずです。
一方、不必要に使用された場合、この複雑さは、将来そのコードを読んだり変更したりする必要のある人々にとって負担となります。

目的が単純であるはずのコードが非常に複雑になった場合、同じことを達成するためにもっと単純な方法がないか、実装を見直す合図になることが多いのです。

<a id="least-mechanism"></a>

#### Least mechanism: 最小限の機構

同じアイデアを表現する方法がいくつかある場合、最も標準的なツールを使用するものを選びます。
洗練された機構はしばしば存在するが、理由なく採用すべきではありません。
必要に応じてコードに複雑さを加えるのは簡単だが、既存の複雑さが不要とわかった後に取り除くのはずっと難しいです。

1. 使用するケースに応じて、コアとなる言語構成要素（チャネル、スライス、マップ、ループ、構造体など）を十分に使用することを目指します。
2. それらがない場合は、標準ライブラリ内のツール（HTTPクライアントやテンプレートエンジンなど）を探します。
3. 最後に、新しい依存関係を導入したり、独自のライブラリを作成したりする前に、Googleのコードベースに十分なコアライブラリがあるかどうかを検討します。

例として、テスト時にオーバーライドしなければならないデフォルト値を持つ変数に束縛されたフラグを含むプロダクションコードを考えてみましょう。
プログラムのコマンドラインインタフェース自体をテストするのでなければ (例えば `os/exec` を使って)、 `flag.Set` を使うよりも、バインドされた値を直接オーバーライドする方が簡単で好ましいです。

同様に、あるコードがセットメンバーシップのチェックを必要とする場合、ブーリアン値のマップ（例：`map[string]bool`）で十分なことが多いです。
集合のような型や機能を提供するライブラリは、マップでは不可能な、または過度に複雑な操作が必要な場合にのみ使用する必要があります。

<a id="concision"></a>

### Concision

簡潔なGoコードは、高いSN比を持っています。
関連する詳細を見分けるのは簡単で、命名と構造によって読者を導いてくれます。

その時々に最も重要なディテールを浮上させるためには、さまざまなことが邪魔になります：

* 繰り返しのコード
* 外来語シンタックス
* [不透明な名前](#naming)
* 不要な抽象化
* ホワイトスペース

特に繰り返しコードは、ほぼ同一の各セクション間の差異を不明瞭にし、読み手は類似のコード行を視覚的に比較して変更点を見つける必要があります。
[Table-driven testing] (テーブル駆動テスト) は、各繰り返しの重要な詳細から共通のコードを簡潔に因数分解できる仕組みの良い例ですが、どの部分をテーブルに含めるかの選択が、テーブルのわかりやすさに影響します。

複数のコード構成方法を検討する場合、どの方法が重要な詳細を最も明確にすることができるかを検討する価値があります。
一般的なコード構文やイディオムを理解し使用することも、高い S/N 比を維持するために重要です。
例えば、以下のコードブロックは [error handling] (エラー処理) で非常によく使われるもので、読者はこのブロックの目的をすぐに理解することができます。

```go
// Good:
if err := doSomething(); err != nil {
    // ...
}
```

これとよく似たコードでも、微妙に違っている場合、読者はその変化に気づかないかもしれません。このような場合は、エラーチェックのシグナルを意図的に ["boosting"] し、注意を喚起するコメントを追加する価値があります。

```go
// Good:
if err := doSomething(); err == nil { // if NO error
    // ...
}
```

[Table-driven testing]: https://github.com/golang/go/wiki/TableDrivenTests
[error handling]: https://go.dev/blog/errors-are-values
["boosting"]: best-practices#signal-boost

<a id="maintainability"></a>

### Maintainability

コードは、書かれるよりも何度も編集されるものです。
読みやすいコードは、その仕組みを理解しようとする読者にとって意味があるだけでなく、それを変更する必要のあるプログラマーにとっても意味があるのです。わかりやすさは重要です。

保守性の高いコード：

* 将来のプログラマが正しく修正することが容易であること
* 優雅に成長できるように構造化されたAPIを持つ
* 前提条件を明確にし、コードの構造ではなく、問題の構造に対応する抽象化を選択する
* 不必要な結合を避け、使用されない機能を含めない
* 約束された動作が維持され、重要なロジックが正しいことを確認するための包括的なテストスイートがあり、テストが失敗した場合に明確で実用的な診断を提供する

インターフェースや型のように、定義上、使用されるコンテキストから情報を取り除く抽象化を使用する場合、十分な利点を提供することを保証することが重要です。
エディターやIDEは、具体的な型を使用する場合はメソッドの定義に直接接続し、対応するドキュメントを表示できますが、そうでない場合はインターフェースの定義にしかアクセスできません。
インターフェイスは強力なツールですが、インターフェイスを正しく使用するために、メンテナンス者が基本的な実装の詳細を理解する必要がある場合があり、インターフェイスの文書内またはコールサイトで説明しなければならないため、コストがかかります。

また、保守性の高いコードは、見落としやすい場所に重要な詳細を隠すことも避けられます。
例えば、以下の各コード行では、1文字の有無がその行を理解する上で重要です：

```go
// Bad:
// The use of = instead of := can change this line completely.
if user, err = db.UserByID(userID); err != nil {
    // ...
}
```

```go
// Bad:
// The ! in the middle of this line is very easy to miss.
leap := (year%4 == 0) && (!(year%100 == 0) || (year%400 == 0))
```

どちらも間違いではありませんが、もっと明確に書くか、重要な動作に注意を促すコメントを添えるか、どちらかでしょう：

```go
// Good:
u, err := db.UserByID(userID)
if err != nil {
    return fmt.Errorf("invalid origin user: %s", err)
}
user = u
```

```go
// Good:
// Gregorian leap years aren't just year%4 == 0.
// See https://en.wikipedia.org/wiki/Leap_year#Algorithm.
var (
    leap4   = year%4 == 0
    leap100 = year%100 == 0
    leap400 = year%400 == 0
)
leap := leap4 && (!leap100 || leap400)
```

同じように、重要なロジックや重要なエッジケースを隠すようなヘルパー関数は、将来の変更でそれを適切に考慮できなくなる可能性があります。

予測可能な名前は、保守可能なコードのもう一つの特徴です。
パッケージのユーザーやコード片のメンテナは、パッケージの名前を予測することができるはずです。
変数、メソッド、または関数を指定されたコンテキストで使用します。
同じ概念の関数パラメータとレシーバー名は、通常、同じ名前を共有する必要があります。これは、ドキュメントを理解しやすくし、最小限のオーバーヘッドでコードのリファクタリングを容易にするためです。

保守性の高いコードは、依存関係を最小限に抑えます（暗黙的、明示的の両方）。
より少ないパッケージへの依存は、動作に影響を与えるコードの行数を減らすことを意味します。
内部的な動作や文書化されていない動作への依存を避けることで、将来それらの動作が変わったときに保守の負担になる可能性が低くなります。

コードをどのように構成するか、あるいは書くかを考えるとき、そのコードが時間の経過とともにどのように変化していくかを考える時間を取る価値があります。
あるアプローチの方が、将来的な変更をより簡単かつ安全に行えるのであれば、たとえ設計が多少複雑になったとしても、それは良いトレードオフとなることが多いです。

<a id="consistency"></a>

### Consistency

一貫性のあるコードとは、より広いコードベース全体、チームやパッケージのコンテキスト、さらには1つのファイル内でも、同様のコードに見え、感じ、動作するコードのことを指します。

一貫性の問題は、上記の原則を覆すものではありませんが、もし同点が破られなければならない場合、一貫性を優先して破ることが有益であることが多いのです。

パッケージ内の一貫性は、多くの場合、最も直接的な重要レベルです。
同じ問題がパッケージ全体で複数の方法でアプローチされていたり、同じコンセプトがファイル内で多くの名前を持っていたりすると、非常に不快に感じることがあります。
しかし、このような場合でも、文書化されたスタイルの原則やグローバルな一貫性を覆すべきではありません。

<a id="core"></a>

## Core guidelines

これらのガイドラインは、すべてのGoコードが従うことが期待されるGoスタイルの最も重要な側面を集めたものです。
これらの原則は、可読性が付与されるまでに学習され、遵守されることを期待しています。
これらは頻繁に変更されることはないと思われ、新しく追加されるものは高いハードルをクリアしなければならないでしょう。

以下のガイドラインは、[Effective Go] の推奨事項を拡張したもので、コミュニティ全体のGoコードに共通のベースラインを提供します。

[Effective Go]: https://go.dev/doc/effective_go

<a id="formatting"></a>

### Formatting

すべてのGoソースファイルは `gofmt` ツールが出力するフォーマットに準拠する必要があります。
このフォーマットは、Googleコードベースのpresubmitチェックによって強制されます。
[Generated code] (生成されたコード) も一般的にはフォーマットされるべきです。（例えば、コード検索で閲覧することができるため、 [`format.Source`] を使って）

[Generated code]: https://docs.bazel.build/versions/main/be/general.html#genrule
[`format.Source`]: https://pkg.go.dev/go/format#Source

<a id="mixed-caps"></a>

### MixedCaps

Goのソースコードでは、複数単語の名前を書くときにアンダースコア（スネークケース）ではなく、`MixedCaps` または `mixedCaps`（キャメルケース）を使用します。

これは、他の言語での慣例を破っている場合でも適用されます。
例えば、定数は、エクスポートされた場合は `MaxLength` (`MAX_LENGTH` ではなく)、エクスポートされていない場合は `maxLength` (`max_length` ではなく)となります。

ローカル変数は、初期資本金を選択する目的で、[unexported] とみなされます。

<!--#include file="/go/g3doc/style/includes/special-name-exception.md"-->

[unexported]: https://go.dev/ref/spec#Exported_identifiers

<a id="line-length"></a>

### Line length

Goのソースコードには、決まった行の長さはありません。
行が長すぎると感じたら、改行するのではなく、リファクタリングする必要があります。
すでに実用的なほど短くなっている場合は、その行は長いままでよいでしょう。

行を分割しないでください：

* [インデント変更](decisions.ja.md#indentation-confusion) の前 (例：関数宣言、条件分岐)
* 長い文字列（URLなど）を複数の短い行に収まるようにする

<a id="naming"></a>

### Naming

ネーミングは科学というより芸術です。
Goでは、他の多くの言語よりも名前がやや短くなる傾向がありますが、同じ [general guidelines] が適用されます。

ネーミングは下記であるべきです：

* 使用時に [repetitive](decisions.ja.md#repetition) (繰り返し) を感じさせない
* 文脈を考慮する
* すでに明確になっている概念を繰り返さない

ネーミングに関するより具体的なガイダンスは、[decisions](decisions.ja.md#naming) を参照してください。

[general guidelines]: https://testing.googleblog.com/2017/10/code-health-identifiernamingpostforworl.html

<a id="local-consistency"></a>

### Local consistency

スタイルガイドが特定のスタイルについて何も述べていない場合、近接するコード（通常は同じファイルやパッケージ内ですが、チームやプロジェクトのディレクトリ内の場合もあります）がその問題について一貫した姿勢をとっていない限り、著者は自分の好きなスタイルを自由に選択することができます。

**有効な**ローカルスタイルの考慮の例：

* エラーの書式付き印刷には `%s` または `%v` を使用する
* ミューテックスの代わりにバッファードチャンネルを使用する

**無効な**ローカルスタイルの考慮の例：

* コードの行数制限
* アサーションベーステストライブラリの使用

ローカルスタイルがスタイルガイドと異なるが、可読性への影響が1つのファイルに限られる場合、一般的にはコードレビューで表面化し、一貫した修正は問題のCLの範囲外で行ないます。
この場合、修正を追跡するためにバグを報告することが適切です。

変更によって既存のスタイルの逸脱が悪化したり、より多くのAPIサーフェスで露出したり、逸脱が存在するファイルの数が増えたり、実際のバグが発生したりする場合は、ローカルな一貫性は、新しいコードでスタイルガイドに違反する正当な理由とはならなくなる。
このような場合、作者は同じCLで既存のコードベースをクリーンアップするか、現在のCLより先にリファクタリングを行うか、少なくともローカルな問題を悪化させない代替案を見つけることが適切である。

{% endraw %}
